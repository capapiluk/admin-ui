import "./chunk-763AARI2.js";
import {
  Fragment,
  Teleport,
  computed,
  createBaseVNode,
  createBlock,
  createCommentVNode,
  createElementBlock,
  defineComponent,
  guardReactiveProps,
  inject,
  markRaw,
  mergeProps,
  nextTick,
  normalizeClass,
  normalizeProps,
  normalizeStyle,
  onBeforeUnmount,
  onMounted,
  openBlock,
  provide,
  readonly,
  ref,
  renderList,
  renderSlot,
  resolveDynamicComponent,
  shallowReactive,
  shallowRef,
  toDisplayString,
  toRef,
  toRefs,
  triggerRef,
  unref,
  watch
} from "./chunk-6XECGMJ4.js";
import "./chunk-CF3WPAMV.js";

// node_modules/notivue/dist/index.js
var x = "Notivue__";
var ut = 6e3;
var v = {
  SUCCESS: "success",
  ERROR: "error",
  WARNING: "warning",
  INFO: "info",
  PROMISE: "promise",
  PROMISE_RESOLVE: "promise-resolve",
  PROMISE_REJECT: "promise-reject"
};
var z = ((t) => (t[t.PUSH = 0] = "PUSH", t[t.HEIGHT = 1] = "HEIGHT", t[t.SILENT = 2] = "SILENT", t))(z || {});
var ae = {
  title: "",
  message: "",
  duration: ut,
  ariaLive: "polite",
  ariaRole: "status"
};
var Ae = {
  ...ae,
  ariaLive: "assertive",
  ariaRole: "alert"
};
var lt = {
  ...ae,
  duration: 1 / 0
};
var ct = {
  ...Ae,
  ariaLive: "polite"
};
var dt = {
  ...ae
};
var ft = {
  [v.SUCCESS]: ae,
  [v.ERROR]: Ae,
  [v.WARNING]: ct,
  [v.INFO]: dt,
  [v.PROMISE]: lt,
  [v.PROMISE_RESOLVE]: ae,
  [v.PROMISE_REJECT]: Ae
};
function vt(t, e) {
  return e.props || (e.props = {}), {
    ...t[e.type] ?? t.success,
    ...t.global,
    ...e
  };
}
var re = typeof window > "u";
function J(t) {
  return t.pointerType === "mouse";
}
function Ke(t) {
  return Object.entries(t).reduce(
    (e, [s, o]) => ({
      ...e,
      [s]: shallowRef(o)
    }),
    {}
  );
}
function Qe(t, e) {
  const s = { ...t };
  for (const o in e)
    e.hasOwnProperty(o) && (e[o] && typeof e[o] == "object" ? s[o] = Qe(t[o], e[o]) : s[o] = e[o]);
  return s;
}
function ie() {
  return window.matchMedia("(prefers-reduced-motion: reduce)").matches;
}
var Be = {
  pauseOnHover: true,
  pauseOnTouch: true,
  pauseOnTabChange: true,
  enqueue: false,
  position: "top-center",
  teleportTo: "body",
  notifications: ft,
  limit: 1 / 0,
  animations: {
    enter: x + "enter",
    leave: x + "leave",
    clearAll: x + "clearAll"
  }
};
function mt(t) {
  const e = Ke(Qe(Be, t));
  return {
    ...e,
    isTopAlign: computed(() => e.position.value.startsWith("top"))
  };
}
function Ue(t, e) {
  let s = 0;
  function o(i, n, a = `${s++}`) {
    return typeof i == "string" && (i = { message: i }), t.pushProxy({ ...i, id: a, type: n }), {
      id: a,
      clear: () => t.clearProxy(a),
      destroy: () => t.clearProxy(a, true)
    };
  }
  return {
    success: (i) => o(i, v.SUCCESS),
    error: (i) => o(i, v.ERROR),
    warning: (i) => o(i, v.WARNING),
    info: (i) => o(i, v.INFO),
    promise: (i) => {
      const { id: n, clear: a, destroy: f } = o(i, v.PROMISE);
      return {
        resolve: (c) => o(c, v.PROMISE_RESOLVE, n),
        reject: (c) => o(c, v.PROMISE_REJECT, n),
        clear: a,
        destroy: f
      };
    },
    clearAll: () => e.addClearAllClass(),
    destroyAll: () => t.reset()
  };
}
function pt() {
  const t = new Proxy({}, { get: () => () => {
  } });
  return Ue(t, t);
}
var Xe = Symbol("");
function ht(t) {
  const e = mt(t), s = {
    entries: shallowRef([]),
    queue: shallowRef([]),
    isStreamPaused: ref(false),
    isStreamFocused: ref(false),
    /* ====================================================================================
     * Interaction states and store reset
     * ==================================================================================== */
    resetPause() {
      this.isStreamPaused.value = false;
    },
    setStreamFocus() {
      this.isStreamFocused.value = true;
    },
    resetStreamFocus() {
      this.isStreamFocused.value = false;
    },
    reset() {
      this.clearItems(), this.clearQueue(), this.resetPause(), this.resetStreamFocus();
    },
    /* ====================================================================================
     * Active items methods
     * ==================================================================================== */
    add(n) {
      this.entries.value.unshift(n), triggerRef(this.entries), this.addEnterClass(n.id), s.updatePositions();
    },
    get(n) {
      return this.entries.value.find(({ id: a }) => n === a);
    },
    update(n, a) {
      Object.assign(this.get(n) ?? {}, a), triggerRef(this.entries);
    },
    updateAll(n) {
      this.entries.value = this.entries.value.map(n);
    },
    remove(n) {
      this.entries.value = this.entries.value.filter(({ timeout: f, id: c }) => n !== c ? true : (clearTimeout(f), false)), e.enqueue.value && this.queue.value.length > 0 && this.addFromQueue();
    },
    clearItems() {
      this.entries.value = [];
    },
    /* ====================================================================================
     * Queued items methods
     * ==================================================================================== */
    addQueueItem(n) {
      this.queue.value.push(n), triggerRef(this.queue);
    },
    getQueueItem(n) {
      return this.queue.value.find(({ id: a }) => n === a);
    },
    updateQueueItem(n, a) {
      Object.assign(this.getQueueItem(n) ?? {}, a), triggerRef(this.queue);
    },
    removeQueueItem(n) {
      this.queue.value = this.queue.value.filter(({ id: a }) => n !== a);
    },
    addFromQueue() {
      const n = {
        ...this.queue.value[0],
        timeout: this.queue.value[0].timeout(),
        createdAt: Date.now()
      };
      nextTick(() => {
        this.removeQueueItem(n.id), this.add(n);
      });
    },
    clearQueue() {
      this.queue.value = [];
    },
    /* ====================================================================================
     * Proxies - Used by push methods
     *
     * Clear Proxy - Removes a notification and resumes timeouts if needed
     * Push Proxy - Creates, updates or enqueues a notification created using push methods
     * ==================================================================================== */
    clearProxy(n, a = false) {
      var c;
      this.entries.value.length > 1 && ((c = this.entries.value.at(-1)) == null ? void 0 : c.id) === n && this.resumeTimeouts(), a ? this.remove(n) : this.addLeaveClass(n);
    },
    pushProxy(n) {
      const a = Date.now(), f = vt(e.notifications.value, n), c = e.enqueue.value, S = n.skipQueue, m = () => {
        if (!(f.duration === 1 / 0 || this.isStreamPaused.value))
          return window.setTimeout(() => this.addLeaveClass(f.id), f.duration);
      };
      if ([v.PROMISE_REJECT, v.PROMISE_RESOLVE].includes(n.type))
        c && this.getQueueItem(f.id) ? this.updateQueueItem(f.id, { ...f, createdAt: a, timeout: m }) : this.update(f.id, { ...f, createdAt: a, timeout: m() });
      else {
        const p = this.entries.value.length >= e.limit.value;
        !c && p && this.entries.value.slice(e.limit.value - 1).forEach(({ id: X }) => window.setTimeout(() => this.addLeaveClass(X)));
        const R = this.queue.value.length > 0, P = c && (R || p) && !S, q = {
          ...f,
          createdAt: a,
          timeout: P ? m : m(),
          // Will be called when dequeued
          clear: () => this.clearProxy(f.id),
          destroy: () => this.clearProxy(f.id, true)
        };
        P ? this.addQueueItem(q) : this.add(q);
      }
    },
    /* ====================================================================================
     * Timeouts
     * ==================================================================================== */
    pauseTimeouts() {
      if (this.entries.value.length === 0 || this.isStreamPaused.value)
        return;
      const n = Date.now();
      this.updateAll((a) => (clearTimeout(a.timeout), {
        ...a,
        elapsed: n - (a.resumedAt ?? a.createdAt) + (a.elapsed ?? 0)
      })), this.isStreamPaused.value = true;
    },
    resumeTimeouts() {
      this.entries.value.length !== 0 && this.isStreamPaused.value && (this.updateAll((n) => {
        if (clearTimeout(n.timeout), n.elapsed === void 0) {
          const f = this.entries.value.map(({ createdAt: m }) => m), c = Math.max(...f), S = Math.min(...f);
          if (S === c)
            n.elapsed = 1200;
          else {
            const m = (n.createdAt - S) / (c - S);
            n.elapsed = m * (1200 - 200) + 200;
          }
        }
        let a = n.duration - n.elapsed;
        return {
          ...n,
          resumedAt: Date.now(),
          timeout: n.duration === 1 / 0 ? void 0 : window.setTimeout(() => this.addLeaveClass(n.id), a)
        };
      }), this.isStreamPaused.value = false);
    },
    /* ====================================================================================
     * Reactive classes - Animations
     * ==================================================================================== */
    updateClass(n, a, f = () => {
    }) {
      if (!a)
        return f();
      this.update(n, {
        animationClass: a,
        onAnimationstart: (c) => c.stopPropagation(),
        onAnimationend: (c) => {
          c.stopPropagation(), f();
        }
      });
    },
    addEnterClass(n) {
      ie() || (this.updateClass(n, e.animations.value.enter), s.updatePositions());
    },
    addLeaveClass(n) {
      if (ie())
        return this.remove(n);
      this.updateClass(n, e.animations.value.leave, () => this.remove(n)), s.updatePositions();
    },
    /* ====================================================================================
     * Reactive styles - Positions
     * ==================================================================================== */
    updatePositions(n = z.PUSH) {
      const a = o.getSortedItems(), f = ie() || n === z.SILENT;
      let c = 0;
      for (const S of a) {
        const m = e.animations.value.leave, p = S.dataset.notivueId, l = this.get(p);
        !S || !l || l.animationClass === m || (this.update(p, {
          positionStyles: {
            transitionDuration: o.getTransitionData().duration,
            transitionTimingFunction: o.getTransitionData().easing,
            ...n === z.HEIGHT ? { transitionProperty: "all" } : {},
            ...f ? { transition: "none" } : {},
            transform: `translate3d(0, ${c}px, 0)`
          }
        }), c += (e.isTopAlign.value ? 1 : -1) * S.clientHeight);
      }
    }
  }, o = {
    wrapper: ref(null),
    items: ref([]),
    containers: ref([]),
    getSortedItems() {
      return this.items.value.sort((n, a) => +a.dataset.notivueId - +n.dataset.notivueId);
    },
    /* ====================================================================================
     * Transition data
     * ==================================================================================== */
    transitionData: null,
    getTransitionData() {
      return this.transitionData || this.syncTransitionData(), this.transitionData;
    },
    syncTransitionData() {
      var f;
      const n = e.animations.value.enter, a = n ? (f = this.wrapper.value) == null ? void 0 : f.querySelector(`.${n}`) : null;
      if (!a)
        this.transitionData = { duration: "0s", easing: "ease" };
      else {
        const c = getComputedStyle(a);
        this.transitionData = {
          duration: c.animationDuration,
          easing: c.animationTimingFunction
        };
      }
    },
    resetTransitionData() {
      this.transitionData = null;
    },
    /* ====================================================================================
     * Imperative - Animations
     * ==================================================================================== */
    addClearAllClass() {
      if (this.wrapper.value) {
        if (!e.animations.value.clearAll || ie())
          return s.reset();
        this.wrapper.value.classList.add(e.animations.value.clearAll), this.wrapper.value.onanimationend = () => s.reset();
      }
    }
  }, i = Ue(s, o);
  return watch(
    () => [e.enqueue.value, e.limit.value, e.teleportTo.value],
    () => s.reset(),
    { flush: "sync" }
  ), watch(
    () => s.entries.value.length === 0 && s.queue.value.length === 0,
    () => {
      o.resetTransitionData(), s.resetPause(), s.resetStreamFocus();
    }
  ), {
    config: e,
    elements: o,
    items: s,
    push: i
  };
}
var bn = {
  install(t, e = {}) {
    t.provide(Xe, ht(e));
  }
};
var gt = [
  "timeout",
  "elapsed",
  "resumedAt",
  "positionStyles",
  "animationClass",
  "onAnimationstart",
  "onAnimationend"
];
function Re(t) {
  return Object.fromEntries(
    Object.entries(t).filter(
      ([e]) => !gt.includes(e)
    )
  );
}
function We(t) {
  return `${t.title ? `${t.title}: ` : ""}${t.message}`;
}
function ue() {
  var t;
  return (t = le()) == null ? void 0 : t.elements;
}
function B() {
  var t;
  return (t = le()) == null ? void 0 : t.items;
}
function le() {
  return inject(Xe);
}
function U() {
  return re ? Ke({ ...Be, isTopAlign: true }) : le().config;
}
function _t() {
  return re ? pt() : le().push;
}
function Et() {
  if (re)
    return {
      entries: computed(() => []),
      queue: computed(() => [])
    };
  const t = le();
  return {
    entries: computed(() => t.items.entries.value.map(Re)),
    queue: computed(() => t.items.queue.value.map(Re))
  };
}
var yt = ["role", "aria-live"];
var St = defineComponent({
  __name: "AriaLive",
  props: {
    item: {}
  },
  setup(t) {
    const e = t, s = {
      position: "absolute",
      width: "1px",
      height: "1px",
      padding: "0",
      margin: "-1px",
      overflow: "hidden",
      clip: "rect(0, 0, 0, 0)",
      whiteSpace: "nowrap",
      border: "0"
    };
    return (o, i) => (openBlock(), createElementBlock("div", {
      style: s,
      role: e.item.ariaRole,
      "aria-live": e.item.ariaLive,
      key: `${o.item.id}_${o.item.type}`
    }, toDisplayString(unref(We)(e.item)), 9, yt));
  }
});
function bt() {
  const t = B(), e = U();
  function s(i) {
    J(i) && t.pauseTimeouts();
  }
  function o(i) {
    J(i) && t.resumeTimeouts();
  }
  return computed(
    () => e.pauseOnHover.value && !t.isStreamFocused.value ? {
      onPointerenter: s,
      onPointerleave: o
    } : {}
  );
}
function Ct() {
  const t = B(), e = U();
  let s;
  function o(i) {
    J(i) || (t.pauseTimeouts(), clearTimeout(s), s = setTimeout(() => {
      t.resumeTimeouts();
    }, 2e3));
  }
  return onBeforeUnmount(() => {
    clearTimeout(s);
  }), computed(
    () => e.pauseOnTouch.value && !t.isStreamFocused.value ? { onPointerdown: o } : {}
  );
}
var It = { position: "absolute" };
var Fe = { boxSizing: "border-box" };
var Ge = { display: "flex" };
var Tt = { ...Ge, justifyContent: "center" };
var wt = "var(--nv-z, 500)";
var Ft = "var(--nv-gap, 0.75rem)";
var Lt = "var(--nv-root-width, 100%)";
var Ve = {
  top: "var(--nv-root-top, 1.25rem)",
  right: "var(--nv-root-right, 1.25rem)",
  bottom: "var(--nv-root-bottom, 1.25rem)",
  left: "var(--nv-root-left, 1.25rem)"
};
var Le = {
  ol: {
    ...Fe,
    ...Tt,
    margin: "0px auto",
    zIndex: wt,
    maxWidth: Lt,
    padding: "0",
    listStyle: "none",
    position: "fixed",
    pointerEvents: "none",
    inset: Object.values(Ve).join(" ")
  },
  li: {
    ...Fe,
    margin: "0",
    ...Ge,
    ...It,
    position: "absolute",
    transitionProperty: "transform",
    width: "100%"
  },
  item: {
    ...Fe,
    padding: `0 0 ${Ft} 0`,
    pointerEvents: "auto",
    maxWidth: "100%"
  }
};
function Pt() {
  const t = U(), e = computed(() => {
    const i = Object.values(Ve).map((n) => `calc(-1 * ${n})`);
    return t.isTopAlign.value ? i.splice(2, 1, "0px") : i.splice(0, 1, "0px"), { clipPath: `inset(${i.join(" ")})` };
  }), s = (i) => t.position.value.endsWith(i), o = computed(() => ({
    justifyContent: `var(--nv-root-x-align, ${s("left") ? "flex-start" : s("right") ? "flex-end" : "center"})`
  }));
  return computed(() => ({
    ol: { ...Le.ol, ...e.value },
    li: {
      ...Le.li,
      ...o.value,
      ...t.isTopAlign.value ? { top: "0px" } : { bottom: "0px" }
    },
    item: Le.item
  }));
}
function xt(t) {
  if (re)
    return;
  function e() {
    window.matchMedia("(max-width: 1100px)").matches && t();
  }
  onMounted(() => {
    window.addEventListener("resize", e);
  }), onBeforeUnmount(() => {
    window.removeEventListener("resize", e);
  });
}
function At(t, e) {
  let s;
  const o = /* @__PURE__ */ new Set();
  onMounted(() => {
    s = new ResizeObserver((i, n) => {
      i.forEach((a) => {
        o.has(a.target) ? (e(), o.delete(a.target), n.unobserve(a.target)) : o.add(a.target);
      });
    });
  }), watch(
    t,
    (i) => {
      i.length > 0 && i.forEach((n) => s == null ? void 0 : s.observe(n));
    },
    { flush: "post" }
  ), onBeforeUnmount(() => {
    s == null || s.disconnect();
  });
}
function Rt() {
  const t = U(), e = B(), s = ue();
  watch(
    () => e.entries.value.length,
    () => e.updatePositions(z.PUSH),
    { flush: "post" }
  ), xt(() => e.updatePositions(z.SILENT)), At(s.items.value, () => e.updatePositions(z.HEIGHT)), watch(t.isTopAlign, () => e.updatePositions(z.SILENT));
}
function Ot() {
  const t = B(), e = U();
  function s() {
    t.isStreamFocused.value || (document.visibilityState === "visible" ? e.pauseOnTabChange.value && t.resumeTimeouts() : e.pauseOnTabChange.value ? t.pauseTimeouts() : t.reset());
  }
  onMounted(() => {
    document.addEventListener("visibilitychange", s);
  }), onBeforeUnmount(() => {
    document.removeEventListener("visibilitychange", s);
  });
}
var Nt = ["aria-label", "data-notivue-align"];
var $t = ["data-notivue-id", "aria-setsize", "aria-posinset"];
var kt = ["aria-label", "tabindex", "data-notivue-container", "onAnimationstart", "onAnimationend"];
var Cn = defineComponent({
  __name: "Notivue",
  props: {
    class: {},
    containersTabIndex: {},
    listAriaLabel: { default: "Notifications" }
  },
  setup(t) {
    const e = t, s = U(), o = B(), i = ue(), n = Pt(), a = bt(), f = Ct();
    return Ot(), Rt(), onBeforeUnmount(() => {
      o.reset();
    }), (c, S) => (openBlock(), createBlock(Teleport, {
      to: unref(s).teleportTo.value
    }, [
      unref(o).entries.value.length > 0 ? (openBlock(), createElementBlock("ol", mergeProps({
        key: 0,
        "aria-label": e.listAriaLabel
      }, { ...unref(a), ...unref(f) }, {
        "data-notivue-align": unref(s).isTopAlign.value ? "top" : "bottom",
        ref: unref(i).wrapper,
        style: unref(n).ol,
        class: e.class
      }), [
        (openBlock(true), createElementBlock(Fragment, null, renderList(unref(o).entries.value, (m, p) => {
          var l;
          return openBlock(), createElementBlock("li", {
            tabindex: "-1",
            key: m.id,
            "data-notivue-id": m.id,
            "aria-setsize": unref(o).entries.value.length,
            "aria-posinset": p + 1,
            ref_for: true,
            ref: unref(i).items,
            style: normalizeStyle({
              ...unref(n).li,
              ...m.positionStyles
            })
          }, [
            m.ariaLiveOnly ? (openBlock(), createBlock(St, {
              key: 0,
              item: m
            }, null, 8, ["item"])) : (openBlock(), createElementBlock("div", {
              key: 1,
              "aria-label": unref(We)(m),
              tabindex: ((l = c.containersTabIndex) == null ? void 0 : l[m.id]) ?? -1,
              "data-notivue-container": m.id,
              ref_for: true,
              ref: unref(i).containers,
              style: normalizeStyle(unref(n).item),
              class: normalizeClass(m.animationClass),
              onAnimationstart: m.onAnimationstart,
              onAnimationend: m.onAnimationend
            }, [
              renderSlot(c.$slots, "default", mergeProps(unref(Re)(m), {
                key: `${m.id}_${m.type}`
              }))
            ], 46, kt))
          ], 12, $t);
        }), 128))
      ], 16, Nt)) : createCommentVNode("", true)
    ], 8, ["to"]));
  }
});
var qe = 300;
var In = defineComponent({
  __name: "NotivueSwipe",
  props: {
    item: {},
    touchOnly: { type: Boolean, default: false },
    exclude: { default: "a, button" },
    disabled: { type: Boolean, default: false },
    threshold: { default: 0.5 }
  },
  setup(t) {
    const e = t, s = toRef(e, "touchOnly"), o = toRef(e, "exclude"), i = toRef(e, "disabled"), n = toRef(e, "threshold"), a = computed(() => e.item.type === v.PROMISE), f = computed(
      () => !c.isStreamFocused.value && !i.value && !a.value && e.item.duration < 1 / 0
    ), c = B(), S = ue(), m = computed(() => S.items.value[S.items.value.length - 1]), p = ref(null), l = shallowReactive({
      targetLeft: 0,
      targetRight: 0,
      targetWidth: 0,
      isLocked: false,
      isPressed: false,
      isClearing: false,
      startX: 0,
      currentX: 0
    }), R = shallowRef({});
    function P(r) {
      Object.assign(l, r);
    }
    function q(r) {
      R.value = { ...R.value, ...r };
    }
    function de() {
      R.value = {};
    }
    function X() {
      p.value && (q({
        touchAction: "none",
        userSelect: "none",
        cursor: "grab"
      }), p.value.querySelectorAll("*").forEach((r) => {
        r instanceof HTMLElement && (r.style.userSelect = "none", r.style.touchAction = "none");
      }));
    }
    function W() {
      p.value && (de(), p.value.querySelectorAll("*").forEach((r) => {
        r instanceof HTMLElement && (r.style.userSelect = "auto", r.style.touchAction = "auto");
      }));
    }
    function b(r) {
      return !(s.value && r.pointerType !== "touch");
    }
    function G() {
      if (!p.value)
        return;
      const { left: r, right: C, width: H } = p.value.getBoundingClientRect();
      P({
        targetLeft: r,
        targetRight: C,
        targetWidth: H
      });
    }
    function K() {
      q({
        transition: ie() ? "none" : `${qe}ms cubic-bezier(0.76, 0, 0.24, 1)`,
        transform: "translate3d(0px, 0px, 0px)",
        opacity: "1"
      });
    }
    function te(r) {
      return r.clientX > l.targetLeft && r.clientX < l.targetRight;
    }
    function fe(r) {
      b(r) || W();
    }
    function ne(r) {
      b(r) && (r.stopPropagation(), p.value && r.button === 0 && (l.isPressed || l.isClearing || l.isLocked || o.value && Array.from(p.value.querySelectorAll(o.value)).includes(r.target) || (J(r) || c.pauseTimeouts(), P({
        startX: r.clientX,
        isPressed: true
      }))));
    }
    function ve(r) {
      b(r) && (r.stopPropagation(), l.isPressed && (l.isClearing || l.isLocked || (q({
        transition: "none",
        transform: `translate3d(${l.currentX}px, 0px, 0px)`,
        opacity: `${1 - Math.abs(l.currentX) / (l.targetWidth * 0.65)}`
      }), P({
        currentX: r.clientX - l.startX
      }), Math.abs(l.currentX) > l.targetWidth * n.value && (l.isClearing = true, me(r)))));
    }
    function me(r) {
      var H;
      e.item.clear(), J(r) && te(r) ? m.value.contains(p.value) || c.pauseTimeouts() : c.resumeTimeouts();
      const C = parseFloat(((H = S.getTransitionData()) == null ? void 0 : H.duration) ?? 0) * 1e3;
      setTimeout(() => l.isClearing = false, C);
    }
    function pe(r) {
      b(r) && (r.stopPropagation(), l.isPressed && (l.isClearing || l.isLocked || (J(r) && te(r) ? c.pauseTimeouts() : c.resumeTimeouts(), K(), P({
        startX: 0,
        currentX: 0,
        isPressed: false,
        isLocked: true
      }), setTimeout(() => l.isLocked = false, qe))));
    }
    function O(r) {
      b(r) && (r.stopPropagation(), l.isPressed && (l.isClearing || l.isLocked || (K(), P({
        startX: 0,
        currentX: 0,
        isPressed: false,
        isLocked: false
      }), c.resumeTimeouts())));
    }
    const he = [
      ["pointerenter", fe],
      ["pointerdown", ne],
      ["pointermove", ve],
      ["pointerup", pe],
      ["pointerleave", O]
    ];
    function ge() {
      window.addEventListener("resize", G), p.value && he.forEach(([r, C]) => {
        p.value.addEventListener(r, C);
      });
    }
    function _e() {
      window.removeEventListener("resize", G), p.value && he.forEach(([r, C]) => {
        p.value.removeEventListener(r, C);
      });
    }
    return watch(
      f,
      (r, C, H) => {
        nextTick(() => {
          r && (X(), G(), nextTick(ge));
        }), H(() => {
          _e(), W();
        });
      },
      { immediate: true, flush: "post" }
    ), onBeforeUnmount(_e), (r, C) => i.value ? renderSlot(r.$slots, "default", { key: 1 }) : (openBlock(), createElementBlock("div", {
      key: 0,
      ref_key: "itemRef",
      ref: p,
      style: normalizeStyle(R.value)
    }, [
      renderSlot(r.$slots, "default")
    ], 4));
  }
});
var Je = Symbol("");
var Mt = 'a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), [tabindex="0"]';
function Dt() {
  const t = ref(false), e = () => t.value = true, s = () => t.value = false, o = [
    ["keydown", e],
    ["mousedown", s],
    ["touchstart", s]
  ];
  return onMounted(() => {
    o.forEach(([i, n]) => document.addEventListener(i, n));
  }), onBeforeUnmount(() => {
    o.forEach(([i, n]) => document.removeEventListener(i, n));
  }), { isKeyboard: t };
}
function qt() {
  const { wrapper: t } = ue(), e = ref(null);
  function s(i) {
    var a;
    const n = i.target instanceof HTMLElement;
    n && ((a = t.value) != null && a.contains(i.target)) || n && (e.value = i.target);
  }
  function o() {
    e.value ? e.value.focus() : (document.activeElement instanceof HTMLElement && document.activeElement.blur(), document.body.focus());
  }
  return onMounted(() => {
    document.addEventListener("focus", s, true);
  }), onBeforeUnmount(() => {
    document.removeEventListener("focus", s, true);
  }), { focusLastElement: o };
}
var Tn = defineComponent({
  __name: "NotivueKeyboard",
  props: {
    comboKey: { default: "n" },
    handleClicks: { type: Boolean, default: true },
    leaveMessage: { default: "You're leaving the notifications stream. Press Control + N to navigate it again." },
    emptyMessage: { default: "No notifications to navigate" },
    renderAnnouncement: { type: Boolean, default: true },
    maxAnnouncements: { default: 3 }
  },
  setup(t) {
    const e = t, { comboKey: s, handleClicks: o, leaveMessage: i, emptyMessage: n, renderAnnouncement: a, maxAnnouncements: f } = toRefs(e), c = {
      ariaRole: "alert",
      ariaLive: "assertive",
      skipQueue: true,
      ariaLiveOnly: !a.value,
      props: {
        isNotivueKeyboard: true
      }
    }, S = computed(() => ({
      message: i.value,
      ...c
    })), m = computed(() => ({
      message: n.value,
      ...c
    })), p = ue(), l = B(), R = _t(), { queue: P } = Et(), q = U(), { focusLastElement: de } = qt(), { isKeyboard: X } = Dt(), W = ref({ qualified: [], unqualified: [] }), b = ref([]), G = ref([]), K = ref(-1);
    function te(u) {
      K.value = u;
    }
    let fe = 0, ne = true, ve = [];
    const me = computed(() => {
      const u = {};
      return W.value.qualified.forEach((g) => u[g] = K.value), W.value.unqualified.forEach((g) => u[g] = -1), u;
    });
    function pe() {
      b.value.length !== 0 && (te(0), l.setStreamFocus(), l.pauseTimeouts(), nextTick(() => {
        b.value[0].focus();
      }));
    }
    function O({ announce: u = true } = {}) {
      de(), te(-1), l.resetStreamFocus(), l.resumeTimeouts(), u && fe < f.value && (fe++, R.info(S.value));
    }
    provide(Je, {
      containersTabIndex: me,
      elementsTabIndex: readonly(K)
    }), watch(p.containers, he, { deep: true });
    function he(u) {
      const g = { qualified: [], unqualified: [] };
      let Q = [], L = [], T = [];
      u.map((N) => ({ id: N.dataset.notivueContainer, container: N })).sort((N, Z) => +Z.id - +N.id).forEach(({ id: N, container: Z }) => {
        const Ee = Array.from(Z.querySelectorAll(Mt)).filter(
          (we) => we instanceof HTMLElement
        );
        T.push(...Ee), Ee.length > 1 ? (g.qualified.push(N), Q.push(Z)) : (g.unqualified.push(N), L.push(Z));
      }), W.value = g, b.value = Q, G.value = L, ve = T;
    }
    watch(
      b,
      (u, g, Q) => {
        if (u.length === 0)
          return;
        const L = u.length > 0, T = u.some((Ee) => !g.some((we) => we === Ee)), N = T && l.isStreamFocused.value, Z = T && !l.isStreamFocused.value || L && ne;
        N ? u[0].focus() : Z && _e(), Q(() => {
          Z && r();
        });
      },
      { flush: "post" }
    );
    function ge(u) {
      !u.shiftKey && u.key === "Tab" && b.value.length > 0 && (u.preventDefault(), ne && (ne = false), pe(), nextTick(r));
    }
    function _e() {
      r(), document.addEventListener("keydown", ge);
    }
    function r() {
      document.removeEventListener("keydown", ge);
    }
    watch(
      G,
      (u) => {
        !q.enqueue.value || !l.isStreamFocused.value || u.length > 0 && (b.value.length > 0 ? b.value[0].focus() : O({ announce: false }));
      },
      { flush: "post" }
    );
    let C = false;
    watch(
      p.wrapper,
      (u, g, Q) => {
        function L(T) {
          if (T.preventDefault(), T.stopPropagation(), !!l.isStreamFocused.value && X.value) {
            if (C)
              return C = false;
            u != null && u.contains(T.relatedTarget) || O();
          }
        }
        u && u.addEventListener("focusout", L), Q(() => {
          u && u.removeEventListener("focusout", L);
        });
      },
      { immediate: true, flush: "post" }
    );
    function H(u) {
      let g = 0;
      if (b.value.some((L, T) => {
        if (L.contains(u.target) || L === u.target)
          return g = T, true;
      })) {
        if (u.key === "Escape")
          return u.preventDefault(), C = true, O();
        if (!o.value)
          return;
        if ((u.target instanceof HTMLButtonElement || u.target instanceof HTMLAnchorElement) && (u.key === "Â " || u.key === " " || u.key === "Enter")) {
          if (u.preventDefault(), C = true, u.target.click(), P.value.length > 0)
            return;
          const T = b.value[g + 1];
          T ? T.focus() : O();
        }
      }
    }
    function $e(u) {
      if (u.ctrlKey && (u.key === s.value.toLowerCase() || u.key === s.value.toUpperCase())) {
        if (u.preventDefault(), l.isStreamFocused.value)
          return C = true, O();
        b.value.length > 0 ? pe() : R.info(m.value);
      }
    }
    function tt(u) {
      var g;
      l.isStreamFocused.value && !X.value && ((g = p.wrapper.value) != null && g.contains(u.target) || O(), ve.includes(u.target) && O());
    }
    const ke = [
      ["click", tt],
      ["keydown", H],
      ["keydown", $e]
    ];
    return onMounted(() => {
      ke.forEach(([u, g]) => window.addEventListener(u, g));
    }), onBeforeUnmount(() => {
      l.reset(), ke.forEach(([u, g]) => {
        document.removeEventListener(u, g);
      });
    }), (u, g) => renderSlot(u.$slots, "default", normalizeProps(guardReactiveProps({ containersTabIndex: me.value, elementsTabIndex: K.value })));
  }
});
function wn() {
  return re ? {
    elementsTabIndex: ref(-1),
    containersTabIndex: computed(() => ({}))
  } : inject(Je);
}
var j = {
  NOTIFICATION: x + "notification",
  ICON: x + "icon",
  CONTENT: x + "content",
  TITLE: x + "content-title",
  MESSAGE: x + "content-message",
  CLOSE: x + "close",
  CLOSE_ICON: x + "close-icon"
};
var Ht = createBaseVNode("path", { d: "M6,-0c-3.308,-0 -6,2.692 -6,6c-0,3.308 2.692,6 6,6c3.308,-0 6,-2.692 6,-6c-0,-3.308 -2.692,-6 -6,-6Zm3.123,3.989l-3.877,4.616c-0.086,0.102 -0.213,0.162 -0.346,0.164l-0.008,0c-0.131,0 -0.256,-0.055 -0.343,-0.153l-1.662,-1.846c-0.081,-0.085 -0.126,-0.199 -0.126,-0.316c0,-0.254 0.209,-0.462 0.462,-0.462c0.135,0 0.263,0.059 0.35,0.161l1.307,1.451l3.536,-4.209c0.087,-0.101 0.215,-0.159 0.349,-0.159c0.253,-0 0.461,0.208 0.461,0.461c0,0.107 -0.036,0.21 -0.103,0.292Z" }, null, -1);
var Zt = [
  Ht
];
var He = defineComponent({
  __name: "SuccessIcon",
  setup(t) {
    return (e, s) => (openBlock(), createElementBlock("svg", normalizeProps(guardReactiveProps(unref(ee))), Zt, 16));
  }
});
var jt = createBaseVNode("path", { d: "M6,-0c-3.308,-0 -6,2.692 -6,6c-0,3.308 2.692,6 6,6c3.308,-0 6,-2.692 6,-6c-0,-3.308 -2.692,-6 -6,-6Zm-0,9.228c-0.316,0 -0.577,-0.26 -0.577,-0.577c0,-0.316 0.261,-0.577 0.577,-0.577c0.316,0 0.577,0.261 0.577,0.577c-0,0.317 -0.261,0.577 -0.577,0.577Zm0.627,-5.802l-0.166,3.519c-0,0.253 -0.208,0.462 -0.462,0.462c-0.253,-0 -0.461,-0.209 -0.461,-0.462l-0.166,-3.518l0,-0.001c-0,-0.009 -0,-0.018 -0,-0.027c-0,-0.344 0.283,-0.627 0.627,-0.627c0.344,0 0.627,0.283 0.627,0.627c-0,0.009 -0,0.018 -0.001,0.027l0.002,-0Z" }, null, -1);
var zt = [
  jt
];
var Pe = defineComponent({
  __name: "ErrorIcon",
  setup(t) {
    return (e, s) => (openBlock(), createElementBlock("svg", normalizeProps(guardReactiveProps(unref(ee))), zt, 16));
  }
});
var Kt = createBaseVNode("path", { d: "M6,0c-3.308,0 -6,2.692 -6,6c0,3.308 2.692,6 6,6c3.308,0 6,-2.692 6,-6c0,-3.308 -2.692,-6 -6,-6Zm0,2.46c0.428,0 0.78,0.352 0.78,0.78c-0,0.428 -0.352,0.78 -0.78,0.78c-0.428,0 -0.78,-0.352 -0.78,-0.78c0,-0.428 0.352,-0.78 0.78,-0.78Zm1.44,6.78l-2.64,0c-0.263,0 -0.48,-0.217 -0.48,-0.48c0,-0.263 0.217,-0.48 0.48,-0.48l0.84,0l0,-2.64l-0.48,0c-0.263,0 -0.48,-0.217 -0.48,-0.48c0,-0.263 0.217,-0.48 0.48,-0.48l0.96,0c0.263,0 0.48,0.217 0.48,0.48l0,3.12l0.84,0c0.263,0 0.48,0.217 0.48,0.48c0,0.263 -0.217,0.48 -0.48,0.48Z" }, null, -1);
var Qt = [
  Kt
];
var Bt = defineComponent({
  __name: "InfoIcon",
  setup(t) {
    return (e, s) => (openBlock(), createElementBlock("svg", normalizeProps(guardReactiveProps(unref(ee))), Qt, 16));
  }
});
var Ut = createBaseVNode("path", { d: "M11.963,6.037c-0,3.292 -2.671,5.963 -5.963,5.963c-3.292,0 -5.963,-2.671 -5.963,-5.963c0,-3.292 2.671,-5.962 5.963,-5.962c3.292,-0 5.963,2.67 5.963,5.962Zm-0.918,0c0,-2.785 -2.26,-5.045 -5.045,-5.045c-2.785,0 -5.045,2.26 -5.045,5.045c-0,2.786 2.26,5.046 5.045,5.046c2.785,-0 5.045,-2.26 5.045,-5.046Z" }, null, -1);
var Xt = createBaseVNode("path", { d: "M8.401,3.449c0.163,-0.194 0.452,-0.219 0.646,-0.056c0.194,0.163 0.219,0.452 0.056,0.646l-3.853,4.587c-0.085,0.101 -0.21,0.161 -0.343,0.163c-0.133,0.003 -0.26,-0.053 -0.349,-0.151l-1.651,-1.835c-0.169,-0.188 -0.154,-0.479 0.034,-0.648c0.188,-0.169 0.479,-0.154 0.648,0.034l1.298,1.443l3.514,-4.183Z" }, null, -1);
var Wt = [
  Ut,
  Xt
];
var Ze = defineComponent({
  __name: "SuccessOutlineIcon",
  setup(t) {
    return (e, s) => (openBlock(), createElementBlock("svg", normalizeProps(guardReactiveProps(unref(ee))), Wt, 16));
  }
});
var Gt = createBaseVNode("path", { d: "M12, 6c0, 3.313 -2.687, 6 -6, 6c-3.313,-0 -6,-2.688 -6,-6c0,-3.313 2.688,-6 6,-6c3.313,-0 6,2.687 6,6Zm-0.923,-0c-0,-2.803 -2.274,-5.077 -5.077,-5.077c-2.803,0 -5.077,2.274 -5.077,5.077c0,2.803 2.274,5.077 5.077,5.077c2.803,-0 5.077,-2.274 5.077,-5.077Z" }, null, -1);
var Vt = createBaseVNode("path", { d: "M5.373,3.426c-0,-0.009 -0,-0.019 -0,-0.028c-0,-0.342 0.279,-0.624 0.621,-0.627c0.002,-0 0.004,-0 0.006,-0c0.344,-0 0.627,0.283 0.627,0.627c-0,0.009 -0,0.019 -0.001,0.028l0,0.001l-0.165,3.518c-0.012,0.246 -0.215,0.44 -0.461,0.44c-0.246,-0 -0.449,-0.194 -0.461,-0.44l-0.166,-3.518l0,-0.001Z" }, null, -1);
var Jt = createBaseVNode("path", { d: "M6,9.228c-0.316,0 -0.577,-0.26 -0.577,-0.577c0,-0.316 0.261,-0.577 0.577,-0.577c0.316,0 0.577,0.261 0.577,0.577c-0,0.317 -0.261,0.577 -0.577,0.577Z" }, null, -1);
var Yt = [
  Gt,
  Vt,
  Jt
];
var xe = defineComponent({
  __name: "ErrorOutlineIcon",
  setup(t) {
    return (e, s) => (openBlock(), createElementBlock("svg", normalizeProps(guardReactiveProps(unref(ee))), Yt, 16));
  }
});
var en = createBaseVNode("path", { d: "M6, 0c3.313, 0 6, 2.687 6, 6c-0, 3.313 -2.687, 6 -6, 6c-3.313,-0 -6,-2.687 -6,-6c0,-3.313 2.687,-6 6,-6Zm0, 0.96c-2.783, 0 -5.04, 2.257 -5.04, 5.04c0, 2.783 2.257, 5.04 5.04, 5.04c2.783, 0 5.04,-2.257 5.04,-5.04c-0,-2.783 -2.257,-5.04 -5.04,-5.04Z" }, null, -1);
var tn = createBaseVNode("path", { d: "M6.6, 8.28l0.84, 0c0.265, 0 0.48, 0.215 0.48, 0.48c-0, 0.265 -0.215, 0.48 -0.48, 0.48l-2.64,-0c-0.265, 0 -0.48,-0.215 -0.48,-0.48c-0,-0.265 0.215,-0.48 0.48,-0.48l0.84, 0l-0,-2.64l-0.48, 0c-0.265, 0 -0.48,-0.215 -0.48,-0.48c-0,-0.265 0.215,-0.48 0.48,-0.48l0.96, 0c0.265, 0 0.48, 0.215 0.48, 0.48l-0, 3.12Z" }, null, -1);
var nn = createBaseVNode("path", { d: "M6, 2.46c-0.428, 0 -0.78, 0.352 -0.78, 0.78c-0, 0.428 0.352, 0.78 0.78, 0.78c0.428, 0 0.78,-0.352 0.78,-0.78c-0,-0.428 -0.352,-0.78 -0.78,-0.78Z" }, null, -1);
var sn = [
  en,
  tn,
  nn
];
var on = defineComponent({
  __name: "InfoOutlineIcon",
  setup(t) {
    return (e, s) => (openBlock(), createElementBlock("svg", normalizeProps(guardReactiveProps(unref(ee))), sn, 16));
  }
});
var an = createBaseVNode("path", {
  d: "M12,1A11,11,0,1,0,23,12,11,11,0,0,0,12,1Zm0,19a8,8,0,1,1,8-8A8,8,0,0,1,12,20Z",
  opacity: ".25"
}, null, -1);
var rn = createBaseVNode("path", { d: "M10.14,1.16a11,11,0,0,0-9,8.92A1.59,1.59,0,0,0,2.46,12,1.52,1.52,0,0,0,4.11,10.7a8,8,0,0,1,6.66-6.61A1.42,1.42,0,0,0,12,2.69h0A1.57,1.57,0,0,0,10.14,1.16Z" }, [
  createBaseVNode("animateTransform", {
    attributeName: "transform",
    type: "rotate",
    dur: "0.75s",
    values: "0 12 12; 360 12 12",
    repeatCount: "indefinite"
  })
], -1);
var un = [
  an,
  rn
];
var Ye = defineComponent({
  __name: "PromiseIcon",
  setup(t) {
    return (e, s) => (openBlock(), createElementBlock("svg", normalizeProps(guardReactiveProps({ ...unref(Oe), width: 28, height: 28, fill: "currentColor" })), un, 16));
  }
});
var ln = createBaseVNode("line", {
  x1: "18",
  y1: "6",
  x2: "6",
  y2: "18"
}, null, -1);
var cn = createBaseVNode("line", {
  x1: "6",
  y1: "6",
  x2: "18",
  y2: "18"
}, null, -1);
var dn = [
  ln,
  cn
];
var et = defineComponent({
  __name: "CloseIcon",
  setup(t) {
    return (e, s) => (openBlock(), createElementBlock("svg", normalizeProps(guardReactiveProps(unref(fn))), dn, 16));
  }
});
var Oe = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  "aria-hidden": "true"
};
var ee = {
  ...Oe,
  fill: "currentColor",
  viewBox: "0 0 12 12"
};
var fn = {
  ...Oe,
  stroke: "currentColor",
  "stroke-width": 2,
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
var vn = {
  [v.SUCCESS]: markRaw(He),
  [v.ERROR]: markRaw(Pe),
  [v.INFO]: markRaw(Bt),
  [v.WARNING]: markRaw(Pe),
  [v.PROMISE]: markRaw(Ye),
  [v.PROMISE_RESOLVE]: markRaw(He),
  [v.PROMISE_REJECT]: markRaw(Pe),
  close: markRaw(et)
};
var Fn = {
  [v.SUCCESS]: markRaw(Ze),
  [v.ERROR]: markRaw(xe),
  [v.INFO]: markRaw(on),
  [v.WARNING]: markRaw(xe),
  [v.PROMISE]: markRaw(Ye),
  [v.PROMISE_RESOLVE]: markRaw(Ze),
  [v.PROMISE_REJECT]: markRaw(xe),
  close: markRaw(et)
};
var ce = {
  "--nv-width": "360px",
  "--nv-spacing": "0.625rem",
  "--nv-radius": "0.625rem",
  "--nv-icon-size": "1.25rem",
  "--nv-title-size": "1rem",
  "--nv-message-size": "1rem",
  "--nv-tip-width": "0px",
  "--nv-y-align": "center"
};
var Ne = {
  "--nv-shadow": "rgba(0, 0, 0, 0.08) 0px 4px 6px -1px, rgba(0, 0, 0, 0.04) 0px 2px 4px -1px"
};
var mn = {
  ...ce,
  ...Ne,
  // Global
  "--nv-global-bg": "#FFF",
  "--nv-global-fg": "#171717",
  // Scoped
  "--nv-success-accent": "#28B780",
  "--nv-error-accent": "#E74C3C",
  "--nv-warning-accent": "#F59E0B",
  "--nv-info-accent": "#3E8EFF",
  "--nv-promise-accent": "#171717"
};
var Ln = {
  // Layout
  ...ce,
  ...Ne,
  // Success
  "--nv-success-bg": "#E9FAEF",
  "--nv-success-accent": "#059669",
  "--nv-success-fg": "#057452",
  // Error
  "--nv-error-bg": "#FEEFEF",
  "--nv-error-accent": "#E6523C",
  "--nv-error-fg": "#C5412C",
  // Warning
  "--nv-warning-bg": "#FFF0D8",
  "--nv-warning-accent": "#F48533",
  "--nv-warning-fg": "#81471D",
  // Info
  "--nv-info-bg": "#DEF0FA",
  "--nv-info-accent": "#1F70AC",
  "--nv-info-fg": "#1F70AC",
  // Promise
  "--nv-promise-bg": "#FFF",
  "--nv-promise-accent": "#334155",
  "--nv-promise-fg": "#334155"
};
var Pn = {
  ...ce,
  ...Ne,
  // Global
  "--nv-global-accent": "#FFF",
  "--nv-global-fg": "#e7e7e7",
  // Scoped
  "--nv-success-bg": "#178570",
  "--nv-error-bg": "#C94430",
  "--nv-info-bg": "#117AAE",
  "--nv-warning-bg": "#FFE556",
  "--nv-warning-accent": "#4F5358",
  "--nv-warning-fg": "#4F5358",
  "--nv-warning-border": "#4F5358",
  "--nv-promise-accent": "#64748B",
  "--nv-promise-bg": "#FFF",
  "--nv-promise-fg": "#334155"
};
var xn = {
  ...ce,
  "--nv-border-width": "1px",
  // Global
  "--nv-global-bg": "#1F1F1F",
  "--nv-global-border": "#414141",
  "--nv-global-fg": "#D0D0D0",
  // Scoped
  "--nv-success-accent": "#8EF997",
  "--nv-error-accent": "#FF7777",
  "--nv-warning-accent": "#FFE554",
  "--nv-info-accent": "#5FD4FF",
  "--nv-promise-accent": "#D0D0D0"
};
var An = {
  ...ce,
  "--nv-border-width": "1px",
  // Global
  "--nv-global-bg": "#20252E",
  "--nv-global-border": "#353b45",
  "--nv-global-fg": "#F7F7F7",
  // Scoped
  "--nv-success-accent": "#34D399",
  "--nv-error-accent": "#FF7777",
  "--nv-warning-accent": "#FFE554",
  "--nv-info-accent": "#5FD4FF",
  "--nv-promise-accent": "#D0D0D0"
};
var pn = ["data-notivue"];
var hn = ["aria-live", "role"];
var gn = ["textContent"];
var _n = ["textContent"];
var En = ["aria-label"];
var yn = ["textContent"];
var Rn = defineComponent({
  __name: "Notifications",
  props: {
    item: {},
    icons: { default: () => vn },
    theme: { default: () => mn },
    closeAriaLabel: { default: "Close" },
    hideClose: { type: Boolean, default: false }
  },
  setup(t) {
    const e = t, s = computed(() => e.icons[e.item.type]), o = computed(() => e.icons.close);
    return (i, n) => (openBlock(), createElementBlock("div", {
      class: normalizeClass(unref(j).NOTIFICATION),
      "data-notivue": i.item.type,
      style: normalizeStyle(i.theme)
    }, [
      s.value ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        typeof s.value == "object" ? (openBlock(), createBlock(resolveDynamicComponent(s.value), {
          key: 0,
          class: normalizeClass(unref(j).ICON),
          "aria-hidden": "true"
        }, null, 8, ["class"])) : typeof s.value == "string" ? (openBlock(), createElementBlock("div", {
          key: 1,
          class: normalizeClass(unref(j).ICON),
          "aria-hidden": "true"
        }, toDisplayString(s.value), 3)) : createCommentVNode("", true)
      ], 64)) : createCommentVNode("", true),
      createBaseVNode("div", {
        class: normalizeClass(unref(j).CONTENT),
        "aria-live": i.item.ariaLive,
        role: i.item.ariaRole,
        "aria-atomic": "true"
      }, [
        i.item.title ? (openBlock(), createElementBlock("h3", {
          key: 0,
          class: normalizeClass(unref(j).TITLE),
          textContent: toDisplayString(unref(i.item.title))
        }, null, 10, gn)) : createCommentVNode("", true),
        createBaseVNode("p", {
          class: normalizeClass(unref(j).MESSAGE),
          textContent: toDisplayString(unref(i.item.message))
        }, null, 10, _n)
      ], 10, hn),
      !e.hideClose && o.value && i.item.type !== "promise" ? (openBlock(), createElementBlock("button", {
        key: 1,
        class: normalizeClass(unref(j).CLOSE),
        "aria-label": i.closeAriaLabel,
        type: "button",
        tabindex: "-1",
        onClick: n[0] || (n[0] = //@ts-ignore
        (...a) => i.item.clear && i.item.clear(...a))
      }, [
        typeof o.value == "object" ? (openBlock(), createBlock(resolveDynamicComponent(o.value), {
          key: 0,
          class: normalizeClass(unref(j).CLOSE_ICON)
        }, null, 8, ["class"])) : typeof o.value == "string" ? (openBlock(), createElementBlock("div", {
          key: 1,
          "aria-hidden": "true",
          textContent: toDisplayString(o.value)
        }, null, 8, yn)) : createCommentVNode("", true)
      ], 10, En)) : createCommentVNode("", true)
    ], 14, pn));
  }
});
export {
  Rn as Notifications,
  Cn as Notivue,
  Tn as NotivueKeyboard,
  In as NotivueSwipe,
  xn as darkTheme,
  vn as filledIcons,
  mn as lightTheme,
  Pn as materialTheme,
  bn as notivue,
  Fn as outlinedIcons,
  Ln as pastelTheme,
  An as slateTheme,
  Et as useNotifications,
  U as useNotivue,
  U as useNotivueConfig,
  wn as useNotivueKeyboard,
  _t as usePush
};
//# sourceMappingURL=notivue.js.map
